import {
  Bool,
  Field,
  MerkleTree,
  MerkleWitness,
  method,
  Poseidon,
  Provable,
  PublicKey,
  Reducer,
  Signature,
  SmartContract,
  state,
  State,
  Struct
} from 'snarkyjs';

const REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE = 60; // A number between 0 and 100 representing the minimum ratio of signers that must sign a block hash to update the Mina Celestia merkle tree state.
const REQUIRED_MIN_SIGNING_RATIO_FOR_SIGNER_UPDATE = 60; // A number between 0 and 100 representing the minimum ratio of signers that must sign a block hash to update the Mina Signer merkle tree state.

const EMPTY_PUBLIC_KEY = "B62qrhCn7DK2b4pzbJCAxxBN1cyVAyLgN2JZDe67EV76oneJbyiCfDh"; // A dummy Public Key to generate an empty Signer.
const EMPTY_SIGNATURE = "7mXRxyZzn511bfSEnPyWj5jqMBYssxAhTwa81Zb1p4bc4KANxMyJ9CsfHUZ64wTE28kbBZ6UcCWuotQk4TxuYdnQvZcJXKdC"; // A dummy Signature to generate an empty Proof.
const EMPTY_HASH = Field(0); // An empty hash to initialize an empty Merkle tree.

const MAX_CELESTIA_MERKLE_TREE_HEIGHT = 21; // The Celestia merkle tree can hold at most 2^20 (1048576) block hashes.
const MAX_BLOCK_COUNT = 1048576; // Max 1048576 blocks are supported. This number can be increased if needed, but do not forget to change the MAX_CELESTIA_MERKLE_TREE_HEIGHT as well.
const MAX_SIGNER_MERKLE_TREE_HEIGHT = 20; // The Signer merkle tree can hold at most 2^20 (1048576) signers. This is much more than the SIGNER_COUNT, since we do not remove a node from the Signer merkle tree when a Signer is removed.
const MAX_SIGNER_COUNT = 200; // Max 200 signers are supported. This number can be increased if needed.

const celestiaEmptyTree = new MerkleTree(MAX_CELESTIA_MERKLE_TREE_HEIGHT); // To generate an empty CelestiaMerkleWitnessClass.
const signerEmptyTree = new MerkleTree(MAX_SIGNER_MERKLE_TREE_HEIGHT); // To generate an empty SignerMerkleWitnessClass.

// The contract has two CelestiaMerkleWitnessClass since Celestia and Signer merkle trees have different heights.
export class CelestiaMerkleWitnessClass extends MerkleWitness(MAX_CELESTIA_MERKLE_TREE_HEIGHT) {
  // Generate an empty CelestiaMerkleWitnessClass
  static empty(): CelestiaMerkleWitnessClass {
    return new CelestiaMerkleWitnessClass(celestiaEmptyTree.getWitness(0n));
  };
};
export class SignerMerkleWitnessClass extends MerkleWitness(MAX_SIGNER_MERKLE_TREE_HEIGHT) {
  // Generate an empty SignerMerkleWitnessClass
  static empty(): SignerMerkleWitnessClass {
    return new SignerMerkleWitnessClass(signerEmptyTree.getWitness(0n));
  };
};

// Signer holds the information generated by a Signer to verify a block.
// A Signer is a 3rd party node that signs a block hash on Celestia upon request.
// The contract keeps track of `signingCount` of each Signer node as an incentive to sign the block hash.
export class Signer extends Struct({
  key: PublicKey, // The public key of the Signer node.
  witness: SignerMerkleWitnessClass, // The Merkle witness of the Signer node to verify the public key belongs to `signersTree` state.
  signingCount: Field // The number of times this Signer node has signed a block hash on Celestia.
}) {
  constructor(
    key: PublicKey,
    witness: SignerMerkleWitnessClass,
    signingCount: Field
  ) {
    super({
      key,
      witness,
      signingCount
    });
    this.key = key;
    this.witness = witness;
    this.signingCount = signingCount;
  };

  // Create an empty Signer with dummy values.
  static empty() {
    return new Signer(
      PublicKey.fromBase58(EMPTY_PUBLIC_KEY),
      SignerMerkleWitnessClass.empty(),
      Field(0)
    );
  };

  // Return a Bool representing if this Signer belongs to the given merkle tree root hash.
  check(
    root: Field
  ): Bool {
    return root.equals(
      this.witness.calculateRoot(this.hash())
    );
  };

  // Return an hash for this Signer. Hash includes the key as well as the signingCount, as the Signer must prove how many times it has signed.
  hash(): Field {
    return Poseidon.hash(this.key.toFields().concat([this.signingCount]));
  };

  // Return a Bool representing if this Signer is empty.
  isEmpty(): Bool {
    return this.key.equals(PublicKey.fromBase58(EMPTY_PUBLIC_KEY));
  };

  // Create & Return a new Signer with 1 more `signingCount` than this Signer.
  sign(): Signer {
    return new Signer(
      this.key,
      this.witness,
      this.signingCount.add(Field(1))
    );
  };
};

// Each `Block` on Celestia merkle tree is a hash of the block commitment and the height of the block.
export class Block extends Struct({
  commitment: Field, // The block commitment to prove.
  height: Field, // The height of the block.
  witness: CelestiaMerkleWitnessClass // The Merkle witness of the block to verify the block hash belongs to `celestiaBlocksTree` state.
}) {
  constructor(
    commitment: Field,
    height: Field,
    witness: CelestiaMerkleWitnessClass
  ) {
    super({
      commitment,
      height,
      witness
    });
    this.commitment = commitment;
    this.height = height;
    this.witness = witness;
  };

  // Create an empty Block with dummy values
  static empty(): Block {
    return new Block(
      Field(0),
      Field(0),
      CelestiaMerkleWitnessClass.empty()
    );
  };

  // Return an hash for this Block.
  hash(): Field {
    return Poseidon.hash([this.commitment, this.height]);
  };
};

// BlockProof holds the information generated by a Signer to verify a block.
// In order to update Mina state, the user must ask at least REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE % of Signer nodes to sign the block hash of Celestia state.
export class BlockProof extends Struct({
  signer: Signer, // The Signer node that signed this BlockProof.
  signedBlockCommitment: Signature, // The signed block commitment of Celestia state.
  signedBlockHeight: Field // The block height of the block.
}) {
  constructor(
    signer: Signer,
    signedBlockCommitment: Signature,
    signedBlockHeight: Field
  ) {
    super({
      signer,
      signedBlockCommitment,
      signedBlockHeight
    });
    this.signer = signer;
    this.signedBlockCommitment = signedBlockCommitment;
    this.signedBlockHeight = signedBlockHeight;
  };

  // Create an empty BlockProof with dummy values.
  static empty(): BlockProof {
    return new BlockProof(
      Signer.empty(),
      Signature.fromBase58(EMPTY_SIGNATURE),
      Field(0)
    );
  };

  // Return a Bool representing if this BlockProof is an empty BlockProof
  isEmpty(): Bool {
    return this.signer.isEmpty();
  };

  // Return a Bool representing if this BlockProof is valid for a Block.
  verify(
    signerRoot: Field, // The merkle root hash of the Signer merkle tree to verify the `this.signer` belongs is trusted by this smart contract.
    block: Block, // The block to verify the signature of this BlockProof.
  ): Bool {
    return this.signer.check( // If the signer is inside the Signer merkle tree.
      signerRoot
    )
    .and(
      this.signedBlockCommitment.verify( // If the signer signed the block commitment.
        this.signer.key,
        [block.hash()]
      )
    )
    .and(
      this.signedBlockHeight.equals( // If the signed block commitment is for the same block height.
        block.height
      )
    );
  };
};

// SignerProof holds the information generated by a Signer to verify a new Signer.
// In order to join the Mina state as a Signer, the new Signer must ask at least REQUIRED_MIN_SIGNING_RATIO_FOR_SIGNER_UPDATE % of Signer nodes to sign the hash of the new Signer.
export class SignerProof extends Struct({
  signer: Signer, // The Signer node that signed this SignerProof
  signedSignerPublicKey: Signature // The signed public key of the new Signer.
}) {
  constructor(
    signer: Signer,
    signedSignerPublicKey: Signature
  ) {
    super({
      signer,
      signedSignerPublicKey
    });
    this.signer = signer;
    this.signedSignerPublicKey = signedSignerPublicKey;
  };

  // Create an empty SignerProof with dummy values.
  static empty(): SignerProof {
    return new SignerProof(
      Signer.empty(),
      Signature.fromBase58(EMPTY_SIGNATURE)
    );
  };

  // Return a Bool representing if this SignerProof is an empty SignerProof.
  isEmpty(): Bool {
    return this.signer.isEmpty();
  };

  // Return a Bool representing if this SignerProof is valid for a Signer.
  verify(
    signerRoot: Field, // The merkle root hash of the Signer merkle tree to verify the `this.signer` belongs is trusted by this smart contract.
    signer: Signer, // The Signer to verify the signature of this SignerProof.
  ): Bool {
    return this.signer.check(
      signerRoot
    ).and(
      this.signedSignerPublicKey.verify(
        this.signer.key,
        [signer.hash()]
      )
    );
  };
};

// A utility function to fill the given BlockProof array with empty BlockProofs until it reaches MAX_BLOCK_COUNT.
function fillWithEmptyBlockProofs(
  [...proofs]: BlockProof[]
): BlockProof[]{
  const emptyProof = BlockProof.empty();

  for (let i = proofs.length; i < MAX_BLOCK_COUNT; i++)
    proofs[i] = emptyProof;
  return proofs;
};
// A utility function to fill the given BlockProof array with empty SignerProofs until it reaches MAX_SIGNER_COUNT.
function fillWithEmptySignerProofs(
  [...proofs]: SignerProof[]
): SignerProof[]{
  const emptyProof = SignerProof.empty();

  for (let i = proofs.length; i < MAX_SIGNER_COUNT; i++)
    proofs[i] = emptyProof;
  return proofs;
};

// BlockProofList holds an array of Proofs with length MAX_SIGNER_COUNT.
export class BlockProofList extends Struct({
  proofs: Array.from({ length: MAX_SIGNER_COUNT }, () => BlockProof),
  signers: Array.from({ length: MAX_SIGNER_COUNT }, () => PublicKey) // A signer public key array to keep track if the corresponding BlockProof Signer has already signed or not.
}) {
  constructor(
    proofs: BlockProof[]
  ) {
    const signers = Array.from({ length: MAX_SIGNER_COUNT }, () => PublicKey.fromBase58(EMPTY_PUBLIC_KEY));

    super({
      proofs,
      signers
    });

    this.proofs = fillWithEmptyBlockProofs(proofs.splice(0, MAX_SIGNER_COUNT));
    this.signers = signers;
  };
};

// SignerProofList holds an array of Proofs with length MAX_SIGNER_COUNT
export class SignerProofList extends Struct({
  proofs: Array.from({ length: MAX_SIGNER_COUNT }, () => SignerProof),
  signers: Array.from({ length: MAX_SIGNER_COUNT }, () => PublicKey) // A signer public key array to keep track if the corresponding SignerProof Signer has already signed or not.
}) {
  constructor(
    proofs: SignerProof[]
  ) {
    const signers = Array.from({ length: MAX_SIGNER_COUNT }, () => PublicKey.fromBase58(EMPTY_PUBLIC_KEY));

    super({
      proofs,
      signers
    });

    this.proofs = fillWithEmptySignerProofs(proofs.splice(0, MAX_SIGNER_COUNT));
    this.signers = signers;
  };
};

export class Photon extends SmartContract {
  @state(Field) celestiaNamespaceHash = State<Field>(); // The namespace of the Celestia blocks. As each dApp can have a different namespace, creating a different Mina contract for each dApp is better, instead of keeping all blocks on the same merkle tree identified with their namespace.
  @state(Field) celestiaBlocksTree = State<Field>(); // Merkle root hash of `Block` tree on Celestia.
  @state(Field) signerCount = State<Field>(); // Number of Signers registered to the contract.
  @state(Field) signersTree = State<Field>(); // Merkle root hash of Signer nodes of Photon.
  @state(Field) signersTreeAccumulator = State<Field>(); // Accumulator of Signer nodes of Photon.

  reducer = Reducer({ actionType: Signer });

  init() {
    super.init();
    this.celestiaNamespaceHash.set(Field(0));
    this.celestiaBlocksTree.set(EMPTY_HASH);
    this.signerCount.set(Field(0));
    this.signersTree.set(EMPTY_HASH);
    this.signersTreeAccumulator.set(Reducer.initialActionState);
  };

  // Initialize the contract with the given Celestia namespace hash and the initial Celestia and Signer merkle tree root hashes.
  @method initialize(
    celestiaNamespaceHash: Field,
    initialCelestiaRootHash: Field,
    initialSignerCount: Field,
    initialSignerRootHash: Field
  ) {
    this.celestiaNamespaceHash.assertEquals(Field(0));
    this.celestiaBlocksTree.assertEquals(EMPTY_HASH);
    this.signerCount.assertEquals(Field(0));
    this.signersTree.assertEquals(EMPTY_HASH);

    this.celestiaNamespaceHash.set(celestiaNamespaceHash);
    this.celestiaBlocksTree.set(initialCelestiaRootHash);
    this.signerCount.set(initialSignerCount);
    this.signersTree.set(initialSignerRootHash);
  };

  // Update the Celestia merkle tree with the given new block hash and block height.
  @method update(
    newBlock: Block, // The new `Block` to be included in Celestia merkle tree.
    // Each proof is given as a different argument instead of an array because of a bug in the OCaml.
    proof1: BlockProof,  proof2: BlockProof,  proof3: BlockProof,  proof4: BlockProof,  proof5: BlockProof,  proof6: BlockProof,  proof7: BlockProof,  proof8: BlockProof,  proof9: BlockProof,  proof10: BlockProof, proof11: BlockProof, proof12: BlockProof, proof13: BlockProof, proof14: BlockProof, proof15: BlockProof, proof16: BlockProof, proof17: BlockProof, proof18: BlockProof, proof19: BlockProof, proof20: BlockProof 
  ) {
    this.celestiaBlocksTree.assertEquals(this.celestiaBlocksTree.get());
    this.signerCount.assertEquals(this.signerCount.get());
    this.signersTree.assertEquals(this.signersTree.get());
    this.signersTreeAccumulator.assertEquals(this.signersTreeAccumulator.get());

    // const celestiaBlocksTree = this.celestiaBlocksTree.get();
    const signerCount = this.signerCount.get();
    const signersTree = this.signersTree.get();
    // const signersTreeAccumulator = this.signersTreeAccumulator.get();

    const newBlockProvers = new BlockProofList([
      proof1, proof2, proof3, proof4, proof5, proof6, proof7, proof8, proof9, proof10, proof11, proof12, proof13, proof14, proof15, proof16, proof17, proof18, proof19, proof20
    ]);

    signerCount.equals(Field(0)).assertEquals(Bool(false)); // There is at least 1 signer

    let allValid = Bool(true);
    let currSignerCount = Field(0); // Number of Signers signed this proof.

    for (let i = 0; i < MAX_SIGNER_COUNT; i++) {
      const proof = newBlockProvers.proofs[i];

      let countOfSigners = Field(0); // This should stay 0 for all signers if all signers are unique.

      // Go through the array to see if this public key is already added.
      for (let i = 0; i < MAX_SIGNER_COUNT; i++)
        countOfSigners = countOfSigners.add(
          Provable.if(
            newBlockProvers.signers[i].equals(proof.signer.key),
            Field(1),
            Field(0)
          )
        );

      newBlockProvers.signers[i] = proof.signer.key; // Used once, so add it to the list.

      allValid = allValid.and(
        Bool.or(
          proof.isEmpty(),
          Bool.and(
            proof.verify(
              signersTree,
              newBlock
            ),
            countOfSigners.equals(Field(0))
          )
        )
      );

      currSignerCount = currSignerCount.add(
        Provable.if(
          proof.isEmpty(),
          Field(0),
          Field(1)
        )
      );

      // This line is not working since right now you can only dispatch 100 Field elements inside a @method, and number of signers can be more than 100.
      // this.reducer.dispatch(proof.signer); // Update the signer state with the new `signingCount`.
    };

    allValid.assertEquals(Bool(true)); // Check no validity check has failed.
    currSignerCount.mul(Field(100)).assertGreaterThanOrEqual(signerCount.mul(Field(REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE))); // More than REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE % of signers should sign the `BlockProof`.

    // As we cannot dispatch more than 100 Field elements inside a @method, no need for this code right now.
    // The contract works as expected without the reducer logic, it just does not update the `signingCount` of the Signer nodes.
    // const { state: newSignersTree, actionState: newSignersTreeAccumulator } = this.reducer.reduce(
    //   this.reducer.getActions({ fromActionState: signersTreeAccumulator }), // The current accumulator state.
    //   Field, // State type - merkle root
    //   (state: Field, action: Signer) => {
    //     action = action.sign(); // Add 1 signing to the signer.
    //     return action.witness.calculateRoot(action.hash()); // Update the merkle tree state.
    //   },
    //   { state: signersTree, actionState: signersTreeAccumulator }
    // );

    const newCelestiaBlocksTree = newBlock.witness.calculateRoot(newBlock.hash()); // The new Celestia merkle tree root hash.

    this.celestiaBlocksTree.set(newCelestiaBlocksTree);
    // this.signersTree.set(newSignersTree);
    // this.signersTreeAccumulator.set(newSignersTreeAccumulator);
  };

  // Register a new Signer node to the contract.
  @method register(
    newSigner: Signer, // The new Signer to be included in Signer merkle tree.
    // Each proof is given as a different argument instead of an array because of a bug in the OCaml.
    proof1: SignerProof,  proof2: SignerProof,  proof3: SignerProof,  proof4: SignerProof,  proof5: SignerProof,  proof6: SignerProof,  proof7: SignerProof,  proof8: SignerProof,  proof9: SignerProof,  proof10: SignerProof, proof11: SignerProof, proof12: SignerProof, proof13: SignerProof, proof14: SignerProof, proof15: SignerProof, proof16: SignerProof, proof17: SignerProof, proof18: SignerProof, proof19: SignerProof, proof20: SignerProof 
  ) {
    this.signerCount.assertEquals(this.signerCount.get());
    this.signersTree.assertEquals(this.signersTree.get());
    this.signersTreeAccumulator.assertEquals(this.signersTreeAccumulator.get());

    const signerCount = this.signerCount.get();
    const signersTree = this.signersTree.get();
    // const signersTreeAccumulator = this.signersTreeAccumulator.get();

    signerCount.assertLessThan(Field(MAX_SIGNER_COUNT)); // There is at most MAX_SIGNER_COUNT Signers, else you should remove a signer first.

    const newSignerProvers = new SignerProofList([
      proof1, proof2, proof3, proof4, proof5, proof6, proof7, proof8, proof9, proof10, proof11, proof12, proof13, proof14, proof15, proof16, proof17, proof18, proof19, proof20
    ]);

    signerCount.equals(Field(0)).assertEquals(Bool(false)); // There is at least 1 signer

    let allValid = Bool(true);
    let currSignerCount = Field(0); // Number of Signers signed this proof.

    for (let i = 0; i < MAX_SIGNER_COUNT; i++) {
      const proof = newSignerProvers.proofs[i];

      let countOfSigners = Field(0); // This should stay 0 for all signers if all signers are unique.

      // Go through the array to see if this public key is already added.
      for (let i = 0; i < MAX_SIGNER_COUNT; i++)
        countOfSigners = countOfSigners.add(
          Provable.if(
            newSignerProvers.signers[i].equals(proof.signer.key),
            Field(1),
            Field(0)
          )
        );

      newSignerProvers.signers[i] = proof.signer.key; // Used once, so add it to the list.

      allValid = allValid.and(
        Bool.or(
          proof.isEmpty(),
          Bool.and(
            proof.verify(
              signersTree,
              newSigner
            ),
            countOfSigners.equals(Field(0))
          )
        )
      );

      currSignerCount = currSignerCount.add(
        Provable.if(
          proof.isEmpty(),
          Field(0),
          Field(1)
        )
      );

      // This line is not working since right now you can only dispatch 100 Field elements inside a @method, and number of signers can be more than 100.
      // this.reducer.dispatch(proof.signer); // Update the signer state with the new `signingCount`.
    };

    allValid.assertEquals(Bool(true)); // Check no validity check has failed.
    currSignerCount.mul(Field(100)).assertGreaterThanOrEqual(signerCount.mul(Field(REQUIRED_MIN_SIGNING_RATIO_FOR_SIGNER_UPDATE))); // More than REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE % of signers should sign the `SignerProof`.

    // As we cannot dispatch more than 100 Field elements inside a @method, no need for this code right now.
    // The contract works as expected without the reducer logic, it just does not update the `signingCount` of the Signer nodes.
    // const { state: newSignersTree, actionState: newSignersTreeAccumulator } = this.reducer.reduce(
    //   this.reducer.getActions({ fromActionState: signersTreeAccumulator }), // The current accumulator state.
    //   Field, // State type - merkle root
    //   (state: Field, action: Signer) => {
    //     action = action.sign(); // Add 1 signing to the signer.
    //     return action.witness.calculateRoot(action.hash()); // Update the merkle tree state.
    //   },
    //   { state: signersTree, actionState: signersTreeAccumulator }
    // );

    signersTree.assertEquals(newSigner.witness.calculateRoot(Signer.empty().hash())); // Check the node was empty before.
    const newSignersTree = newSigner.witness.calculateRoot(newSigner.hash()); // The new Signer merkle tree root hash.

    this.signerCount.set(signerCount.add(Field(1))); // There is a new signer now.
    this.signersTree.set(newSignersTree);
    // this.signersTreeAccumulator.set(newSignersTreeAccumulator);
  };

  // // Remove a Signer from to the contract.
  @method deregister(
    signer: Signer, // The new Signer to be included in Signer merkle tree.
    // Each proof is given as a different argument instead of an array because of a bug in the OCaml.
    proof1: SignerProof,  proof2: SignerProof,  proof3: SignerProof,  proof4: SignerProof,  proof5: SignerProof,  proof6: SignerProof,  proof7: SignerProof,  proof8: SignerProof,  proof9: SignerProof,  proof10: SignerProof, proof11: SignerProof, proof12: SignerProof, proof13: SignerProof, proof14: SignerProof, proof15: SignerProof, proof16: SignerProof, proof17: SignerProof, proof18: SignerProof, proof19: SignerProof, proof20: SignerProof 
  ) {
    this.signerCount.assertEquals(this.signerCount.get());
    this.signersTree.assertEquals(this.signersTree.get());
    this.signersTreeAccumulator.assertEquals(this.signersTreeAccumulator.get());

    const signerCount = this.signerCount.get();
    const signersTree = this.signersTree.get();
    // const signersTreeAccumulator = this.signersTreeAccumulator.get();

    const newSignerProvers = new SignerProofList([
      proof1, proof2, proof3, proof4, proof5, proof6, proof7, proof8, proof9, proof10, proof11, proof12, proof13, proof14, proof15, proof16, proof17, proof18, proof19, proof20
    ]);

    signerCount.equals(Field(0)).assertEquals(Bool(false)); // There is at least 1 signer

    let allValid = Bool(true);
    let currSignerCount = Field(0); // Number of Signers signed this proof.

    for (let i = 0; i < MAX_SIGNER_COUNT; i++) {
      const proof = newSignerProvers.proofs[i];

      let countOfSigners = Field(0); // This should stay 0 for all signers if all signers are unique.

      // Go through the array to see if this public key is already added.
      for (let i = 0; i < MAX_SIGNER_COUNT; i++)
        countOfSigners = countOfSigners.add(
          Provable.if(
            newSignerProvers.signers[i].equals(proof.signer.key),
            Field(1),
            Field(0)
          )
        );

      newSignerProvers.signers[i] = proof.signer.key; // Used once, so add it to the list.

      allValid = allValid.and(
        Bool.or(
          proof.isEmpty(),
          Bool.and(
            proof.verify(
              signersTree,
              signer
            ),
            Bool.and(
              countOfSigners.equals(Field(0)),
              proof.signer.key.equals(signer.key).not() // A node cannot sign the removal of itself.
            )
          )
        )
      );

      currSignerCount = currSignerCount.add(
        Provable.if(
          proof.isEmpty(),
          Field(0),
          Field(1)
        )
      );

      // This line is not working since right now you can only dispatch 100 Field elements inside a @method, and number of signers can be more than 100.
      // this.reducer.dispatch(proof.signer); // Update the signer state with the new `signingCount`.
    };

    allValid.assertEquals(Bool(true)); // Check no validity check has failed.
    currSignerCount.mul(Field(100)).assertGreaterThanOrEqual(signerCount.mul(Field(REQUIRED_MIN_SIGNING_RATIO_FOR_SIGNER_UPDATE))); // More than REQUIRED_MIN_SIGNING_RATIO_FOR_BLOCK_UPDATE % of signers should sign the `SignerProof`.

    // As we cannot dispatch more than 100 Field elements inside a @method, no need for this code right now.
    // The contract works as expected without the reducer logic, it just does not update the `signingCount` of the Signer nodes.
    // const { state: newSignersTree, actionState: newSignersTreeAccumulator } = this.reducer.reduce(
    //   this.reducer.getActions({ fromActionState: signersTreeAccumulator }), // The current accumulator state.
    //   Field, // State type - merkle root
    //   (state: Field, action: Signer) => {
    //     action = action.sign(); // Add 1 signing to the signer.
    //     return action.witness.calculateRoot(action.hash()); // Update the merkle tree state.
    //   },
    //   { state: signersTree, actionState: signersTreeAccumulator }
    // );

    signersTree.assertEquals(signer.witness.calculateRoot(signer.hash())); // Check the witness is correct before.
    const newSignersTree = signer.witness.calculateRoot(Signer.empty().hash()); // Change the node to an empty Signer.

    this.signerCount.set(signerCount.sub(Field(1))); // Remove 1 Signer.
    this.signersTree.set(newSignersTree);
    // this.signersTreeAccumulator.set(newSignersTreeAccumulator);
  };
};
